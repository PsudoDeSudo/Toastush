<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, April 12, 2021, 3:48 PM -->
<!-- MuClient version 5.05 -->

<!-- Plugin "Toastush" generated by Plugin Wizard -->

<muclient>
<plugin
   name="toastush"
   author="Erick Rosso"
   id="843d2f53cb3685465bda7d4a"
   language="Lua"
   date_written="2021-04-12 15:47:28"
   requires="5.05"
   version="2.4"
   save_state="y"
   >
 <description trim="y">

    Welcome to the Miriani MUSHclient soundpack: Toastush.
----------------------------------------

    To get started with configuring the soundpack, type: `toastush:config or toastush:config [option]'
    To view information about the currently running script type: `toastush:info'
    To view the changelog, type: `toastush:changes'
    To send the registration string, type: `toastush:register'
    To reload the updater, type: `toastush:updater-reload or toastush:u-rel'
    To toggle soundpack minimal mode type: `toastush:minimal or toastush:min'



    To fetch updates type: `update'
      - More help about using the updater can be found by typing `update --help'


    To view valid starmap filters type: `sm.help'
    To view valid scan filters type: `sc.help'

    To view this help type: `'toastush:help'


-------------------Key Bindings--------------

    - Audio:
    F10: Cycle forward through audio groups.
    Shift+F10: Cycle backward through audio groups.
    Alt+F10: Toggle global mute.
    F11: Decrease group volume.
    F12: Increase group volume.

    - Miscellaneous:
    ALT+SHIFT+U: Open last url.
    ALT+SHIFT+A: Initialize audio settings. (Helpful in the case of switching soundcards.)
    ALT+SHIFT+I: Read the info bar.




----------------------------------------
 
    ** Once in the game, tune a metaf frequency communicator to 0.07 for in game support. **
</description>
</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<!--  Plugin help  -->

<!--  Timers  -->

<timers>

  <timer
   enabled="y"
   active_closed="y"
   hour="1"
   second="0"
   offset_second="0.00"
   script="detect_update_when_idle"
   send_to="14"
  >
  </timer>


  <timer
   enabled="y"
   name="heartbeat"
   active_closed="y"
   hour="0"
   second="1"
   offset_second="0.00"
   send_to="14"
  >
  <send>
   heartbeat = heartbeat + 1
   

   if (roundtime &gt; 0) then
    roundtime = roundtime - 1
   end -- if

   if (stuntime &gt; 0) then
    stuntime = stuntime - 1
      end -- if

show_stunlock(roundtime, stuntime)

    if (IsConnected()) then 
      if (heartbeat == ping_after_heartbeat) then
             Execute("#$#SOUNDPACK_PING")
      end -- if

   end -- if

   if (heartbeat &gt;= reset_heartbeat) then
       heartbeat = 0
   end -- if

</send>
  </timer>




</timers>


<!-- Triggers -->

<triggers>

  <trigger
 enabled="y"
   script="OnMSP"
   name="MSP"
   match="^(!!SOUND\(.+\))$"
   regexp="y"
   omit_from_output="y"
   send_to="14"
>
  </trigger>

  <trigger
   enabled="y"
   script="OnURL"
   name="http"
   match="((?:https?|ftp|telnet|rsync|mailto|gopher)://[[:graph:]]+[^&quot;])"
   regexp="y"
   send_to="12"
   keep_evaluating="y"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^\^(Creating|Deleting|Updating) Files: \d+%\.{3}$"
   regexp="y"
   omit_from_output="y"
   omit_from_log="y"
   send_to="14"
  >
  <send>notify("info", "%0", 1)</send>
  </trigger>
  <trigger
   enabled="n"
   name="MCP"
   match="^#\$#mcp(-\w+)?(?:-(\w+))? (\S+)(?: (.*))?$"
   regexp="y"
   send_to="12"
   omit_from_output="y"
   omit_from_log="y"
  >
  <send>
   MCP:handle_message("%0")
  </send>
  </trigger>


</triggers>

<aliases>
  <alias
   enabled="y"
   script="help"
   match="^toastush:help$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   script="info"
   match="^toastush:info$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   script="config_main_menu"
   match="^toastush:config(?:ure)?$"
   ignore_case="y"
   regexp="y"
  >
  </alias>

  <alias
   enabled="y"
   match="^toastush:config(?:ure)? (\w+)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
  >
  <send>config_secondary_menu("%1")</send>
  </alias>


  <alias
   enabled="y"
   script="notepad_changelog"
   match="^toastush:changes$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Accessing the changelog...", 1)</send>
  </alias>

  <alias
   enabled="y"
   script="register"
   match="^toastush:register$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>notify("info", "Sending Toastush registration...", 1)</send>
  </alias>

  <alias
   enabled="y"
   match="^toastush:u(pdater)?-rel(oad)?$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>
   notify("info", "Reloading updater...")
   local ok, msg = ReloadPlugin(UPDATE_ID)
   if (ok == 0) then
     notify("info", "Updater reload complete.")
   else
     notify("info", "Updater reload failed.")
   end -- if

  </send>
  </alias>

  <alias
   enabled="y"
   match="^@p(?:aste|ost)$"
   regexp="y"
   ignore_case="y"
   send_to="12"
  >
  <send>

   local result = utils.editbox(
   [[
   Enter the text to send to the world.
   Press "ok" to send, anything else to abort.]], "Paste Edit Box")

   if (result) then
     local paste
     paste = string.gsub(result,
     string.char(10), " ")

     paste = string.gsub(paste,
     string.char(13), "")

     Send(paste)
   end -- if

  </send>
  </alias>


  <alias
   enabled="y"
    name="minimal_mode_alias"
   script="toggle_minimal_mode"
   match="^toastush:min(?:imal)?$"
   regexp="y"
   send_to="12"
  >
  </alias>


</aliases>

<script>
<![CDATA[
require("json")

scripts = "lua/miriani/scripts/"

require(scripts.."init")

MSP, GMCP = 90, 201 
timeout = 120
script = 12
registry = "toastush"
heartbeat = 0
reset_heartbeat = 60
ping_after_heartbeat = 30
roundtime, stuntime = 0, 0



---------------------
-- Macros
Accelerator('F1', 'toastush:config')
AcceleratorTo ("F10", 'forward_cycle_audio_groups()', script) -- cycle forward sound groups.
AcceleratorTo ("SHIFT+F10", 'previous_cycle_audio_groups()', script) -- cycle previous sound groups.

AcceleratorTo("ALT + F10", 'toggle_mute()', script)
AcceleratorTo("F11", 'decrease_attribute("volume")', script)
AcceleratorTo("F12", 'increase_attribute("volume")', script)
AcceleratorTo("ALT+SHIFT+U", 'open_url()', script)
AcceleratorTo("ALT+SHIFT+A", [[
  notify("info", "Initializing audio settings...")
  initialize_audio()
  notify("info", "Audio settings initialized.")]], script)

AcceleratorTo("ALT+SHIFT+I", [[
  local line = ""



  for k,v in pairs(infobar_t) do
    line = line..v.." - "
  end -- for
  notify("info", line, 1)

]], script)






---------------------
-- script routines
local sp_options = require(scripts.."options")
local audio_options = require(scripts.."audio")

function OnPluginInstall()
  math.randomseed(os.time())
  print("Welcome to the MUSHclient Miriani soundpac: [version: ", VERSION, "] For help see toastush:help.")
  print("Toastush now offers a Discord community for support. View toastush:help to get more information.")

  initialize_audio()
  if IsConnected() then
    register()
  end -- if

  -- janitor code
  janitor()

  if (GetVariable("proxiani_enabled")) then
    EnableGroup("starmap", 0)
  end -- if

  -- check for minimal mode.
  if (GetVariable("minimal_mode") == "1") then
    toggle_minimal_groups(0)
  end -- if

end -- OnPluginInstall

function OnPluginSaveState()
  config:save()
end -- OnPluginSave

function OnPluginConnect()
  --register()
  mplay("music/theme", "ambiance", 1)
end -- OnPluginConnect

function OnPluginDisconnect()
  DeleteVariable("proxiani_enabled")
  stop() -- stop all audio.
end -- OnPluginDisconnect

function OnPluginClose()
  stop()
  audio:Free()
end -- OnPluginClose

function OnPluginLoseFocus()

  -- Reset focus flag.
  focusWindow = nil

  -- pause the ambiance
  pause_group("ambiance")
end -- OnPluginLoseFocus

function OnPluginGetFocus()

  -- Set focus flag.
  focusWindow = true

  -- resume the ambiance.
  if config:get_option("background_ambiance").value == "yes" then
    resume_group("ambiance")
  end -- if

end -- OnPluginGetFocus

function OnPluginTelnetRequest (type, data)
  if data == "WILL" then
    if type == GMCP then
      notify("info", "Enabled GMCP")
            return true
    elseif  type == MSP then
      notify("info", "Enabled MSP")
      return true
    end -- if
  end -- if
end -- function OnPluginTelnetRequest

function OnPluginTelnetSubnegotiation (type, data)
   if type == GMCP then
    gmcp_handler(data)
  end -- if
end -- function OnPluginTelnetSubnegotiation

function OnPluginCommandEntered()

  last_command_time = os.time()
  if (searchingScan) then
    searchingScan = false
    scan = nil
   classFilter = nil
  end -- if scan
end -- OnPluginCommandEnter

function OnPluginBroadcast(event, id, name, text)

  if (id == UPDATE_ID) then
    -- update detected.

    local info = json.decode.decode(text)


    for i, u in pairs(info.update) do

      local name = u[i]

      if type(name) == 'string' and string.find(name, "updater.xml") then
        notify("important", "The updater received an update. In order to apply changes, you must reload the plugin.\ntype: `toastush:updater-reload'")
        break
      end -- if
    end -- for

    if config:get_option("automatic_changelog").value == "yes" then
      notepad_changelog()

    end -- if

  end -- if

end -- OnPluginBroadcast


function gmcp_handler(data)

  -- Below follows a typical GMCP implementation.
  -- End users may wish to modify behavior.

  core, params = string.match(data, "([%a.]+)%s+(.*)")
  local info = json.decode(params)

  if core == "communication.channel" then
    Channel(info.channel, info.message, {"channels"})
  elseif core == "communication.say" then
    Channel("say", info.message, {"conversation"})
  elseif core == "communication.tell" then
    Channel("tell", info.message, {"tell"})
  end -- if
end -- gmcp_handler

function OnMSP(name, line, wc)

  local text = wc[1]
  local info = {
  file = string.match(text, "!![%u]+%(([%a%d%p]+).*%)"),
  type = string.match(text, "!![%u]+%(.*T=([%a%d]+).*%)"),
  volume = string.match(text, "!![%u]+%(.*V=([%d]+).*%)"),
  loop = string.match(text, "!![%u]+%(.*L=([%d]+).*%)"),
  continue = string.match(text, "!![%u]+%(.*C=([%d]+).*%)"),
  url = string.match(text, "!![%u]+%(.*U=([%a%d%p]+).*%)")
  }
  msp_handler(info)
end -- OnMSP

function msp_handler(info)

  -- Below follows a typical MSP implementation.
  -- End users may wish to modify behavior.

  play(info.file, info.type)
end -- msp_handler

function on_plugin_update()
  --  Externally called to indicate this plugin should be reloaded upon updates.
  return 1
end -- on_plugin_update

function janitor()

  -- Alert users of proxiani.
  local version = utils.split(VERSION, ".")
  if (tonumber(version[1]) < 3) then
    notify("info", [[

    Info: Beginning Toastush version 3.0.1 and onward, Toastush will now officially support popular Miriani proxy server, Proxiani.
    As a result, when the proxy server is detected, Toastush starmap commands will be disabled.
    Users can expect increased performance, shared features between clients, TLS connectivity and more!
    ]])

    notify("info",
    "See, "..PROXIANI.." for installation details.")

  end -- if


  -- Disable F1 windows help:
  if (GetGlobalOption("F1macro") == 0) then
    db = sqlite3.open(GetInfo (82))  -- open preferences
    db:exec('UPDATE prefs SET value = 1 WHERE name = "F1macro"')
    db:close()  -- close
    utils.reload_global_prefs ()
  end -- if

  -- plugins_updater no longer in use.

  local old_plugins = {
  ["fbd5b7cc1ef6acf827a3f4a1"] = "plugins_updater.xml",
  ["55e1d330539761f176fa0815"] = "indexer.xml", 
  } -- old_plugins

  table.foreach(old_plugins,
  function(id, name)
    if (IsPluginInstalled(id)) then
    print("plugin ", name, " is no longer in use. Unloading.")
    UnloadPlugin(id)
    end -- if
  end ) -- foreach

  -- need an index.
  local path = require("pl.path")
  if (not path.isfile(INDEX)) then
    notify("critical", string.format(
    "Warning: You appear to be missing the index file, '%s'. This file is necessary for updates. To generate the file now, type `index %s'", INDEX, INDEX))
  end -- if

  -- old version downloaded messy files.
  local dir = utils.readdir("*.ogg")
  local js = require("json.decode")
  local f = io.open("index-v5.manifest", "r")

  if (f and dir) then
    local t = f:read("*all")
    f:close()
    local info = js.decode(t)

    local paths = ""
    for path, _ in pairs(info) do
      paths = paths.." "..path
    end -- for

    for file, _ in pairs(dir) do
      if string.find(paths, file) then
        utils.shellexecute("cmd", "/C rmdir "..file, GetInfo(59), nil, 0)
      end -- if
    end -- for
  end -- if
end -- janitor

function detect_update_when_idle()

  if config:get_option("update_idle").value == "yes"
  and IsPluginInstalled(UPDATE_ID)
  and last_command_time ~= nil
  and (os.time() - last_command_time) >= IDLE_CUTOFF then
    Execute("update -q -f")
end -- if

end -- detect_update_when_idle

function toggle_minimal_mode(name, line, wc)
  local minimal_mode = (GetVariable("minimal_mode") == "1") and 1 or 0
  toggle_minimal_groups(minimal_mode)
  if (minimal_mode == 0) then


    SetVariable("minimal_mode", 1)
    notify("info", [[
    The soundpack is now in minimal mode.
    This mode disables the majority of triggers for a clean -- basic environment.
    Communications and miscellaneous gags will remain active.]])
  else

    DeleteVariable("minimal_mode")

    if (name == "minimal_mode_alias") then
      notify("info", "The soundpack is now in full -- regular mode.")
    end -- if
  end -- if
end -- minimal_mode

function toggle_minimal_groups(minimal_mode)
  for k,v in pairs(minimal_groups) do
    EnableGroup(v, minimal_mode)
  end -- for
  end -- toggle_minimal_groups

function initialize_audio()

  if (audio) then
    audio:Free()
  end -- if

  assert(config:init(sp_options, audio_options) == 0)
  -- stereo or mono:
  local channels = config:get_option("audio_channel")

  if (channel ~= nil)
  or channels == {}
  or channels == "no" then
    channels = audio.const.device.mono
  else -- stereo channels
    channels = audio.const.device.stereo
  end -- if

  audio:Init(nil, nil, channels)

end -- initialize_audio

local function sortkeys(mnu)

  local keys = {}
  for k, v in  pairs(mnu) do
    keys[#keys + 1] = k
  end -- for

  table.sort (keys)
  table.foreachi (keys, function(k1, k2) return k2 end)

  return keys
end -- sortkeys

function config_secondary_menu(option)
  local secondary_menu = config:render_menu_list(option)

  if type(secondary_menu) ~= 'table' then
    notify("info", string.format("Unable to locate menu group '%s`.", option))
    return 0
  end -- if 

  table.sort(secondary_menu)

  local group = config:get_option(next(secondary_menu)).group

  local title = string.format("%s Menu", group)

  repeat -- Display menu until escaped.
    mplay("misc/prompt")
      local second_choice = utils.listbox("Select Setting", title, secondary_menu)

    -- Step our user through a sequence to determine the value type.
    if config:is_option(second_choice) then

      if (not config:get_option(second_choice).type)
      or config:get_option(second_choice).type == "bool" then
        -- Interface for boolean value.
        local yes_no = utils.msgbox("Select an option.", title, "yesnocancel", "?")
        config:set_option(second_choice,
        yes_no ~= nil
        and yes_no ~= "cancel"
        and yes_no
        or config:get_option(second_choice).value)
      elseif config:get_option(second_choice).type == "function" then
        local newval = loadstring(config:get_option(second_choice).action)()

        if (newval and newval ~= -1) then
          config:set_option(second_choice, newval)
        else
         config:set_option(second_choice, config:get_option(second_choice).value)
        end -- if
      end -- if
    end -- if

    -- show changes:
    secondary_menu = config:render_menu_list(option)

  until not second_choice

  assert(config:save() == 0)
  mplay("misc/close")

end -- config_secondary_menu


function config_main_menu()
  local main_menu = config:render_menu_list()
  local title = string.format("%s Configuration Manager", GetPluginName()) 

  table.sort(main_menu)

  repeat -- Display main list.
    mplay("misc/prompt")

    local first_choice = utils.listbox("Select Setting", title, main_menu, 1)

    if first_choice then
      config_secondary_menu(main_menu[first_choice])
    end -- if

  until not first_choice

  mplay("misc/close")
end -- config_main_menu

link = {}
infobar_t = {}


---------------------------------


function infobar(id, message, clear)
  id = id or 1

  if clear then
    infobar_t = {}
  end -- if


  local foreground = RGBColourToName(config:get_option("info_foreground_color").value)
  local background = RGBColourToName(config:get_option("info_background_color").value)
  local data = {}
  infobar_t[id] = message

  table.foreach(infobar_t,
  function (k, v)
    data[#(data) + 1] = v
  end ) -- foreach
 
  InfoClear()
  InfoColour(foreground)
  InfoBackground(background)

  Info(
  table.concat(data, " -- "))

end -- infobar

function latency(name, line, wildcard)
  local ms = tonumber(wildcard[1]) or 0
  infobar("lag", string.format ("Latency: %d MS", ms))
end -- latency

function show_stunlock(roundtime, stuntime)
  local roundtime = roundtime or 0
  local stuntime = stuntime or 0
  local stunlock = roundtime + stuntime
  local sec = (stunlock == 1) and "second" or "seconds"

  infobar("stunlock", string.format ("Stunlock: %d %s", stunlock, sec))
end -- show_stunlock

function help(name, line, wc)
  notify("info", string.format("%s", GetPluginInfo(GetPluginID(), 3)))
  ColourTell("silver", "black", "For Discord:     ")
print_hyperlink(DISCORD, DISCORD, "Click to join Discord")
end-- help

function info(name, line, wc)
  local ID = GetPluginID()
  notify("info", string.format("%s  --  version %s  --  Scripting-language: %s  -- Script-time: %s seconds",
  GetPluginInfo(ID, 1),
  VERSION,
  GetPluginInfo(ID, 5),
  GetPluginInfo(ID, 24)))
end -- info

function channel(name, line, wc)

  -- Requires the channel history plugin.

  assert (IsPluginInstalled ("6000a4c6f0e71d31fecf523d"), "channel_history could not be found")

  -- add record table of channel arguments
   for k,v in ipairs(wc) do
    -- Add only if the buffer is active:
        buffer = config:get_option(string.format("%s_buffer", v))

    if buffer ~= nil and
    buffer.value == "yes" then
      Execute("history_add "..v.."="..line)
    end -- if
  end -- for loop
end -- channel

function OnURL(name, line, wc)
  channel("url", wc[1], {"url"})
  --Add the url to a recent url buffer.
  link =
  {
    url = wc[1],
    timestamp = os.clock()
 }
end -- OnURL

function open_url()

  if (not link)
  or os.clock() - link.timestamp > timeout then
    notify("info", "No url to open.")
  else
    local url = link.url
    notify("info", "Opening "..url, 1)
    play("audio/mouseClick.ogg")
    OpenBrowser(url)
  end -- if
end -- open_url

function mplay(file, group, interrupt, pan, loop, slide, sec)
  -- Miriani only play:
  local filepath

  if (config:get_option("alternate_audio").value == "yes") then
    local path = require("pl.path")
    local dir, fn = path.splitpath(file)
    if (path.isfile(config:get("SOUND_DIRECTORY")..ALTPATH..fn..ALT_EXTENSION)) then
      filepath = ALTPATH..fn..ALT_EXTENSION
    end -- if
  end -- if

  if (not filepath) then
    filepath = string.format(SOUNDPATH.."%s%s", file, EXTENSION)
  end -- if

  play(filepath, group, interrupt, pan, loop, slide, sec)
end -- mplay

function speech_interrupt(line)
  Execute("tts_interrupt "..line)
end -- speech_interrupt

function register()
  Send("#$#REGISTER_SOUNDPACK "..registry.." | "..VERSION.."\n")
end -- register

function set_environment(name, line, wc)
  environment = {}

  environment.name = name
  environment.line = line

  -- iterate through a table of flags
  -- and set all to true.
  -- split any deliminated tags and make them into their own truth value.

  for _, flag in ipairs(wc) do

    local names = utils.split(flag, " ")

    table.foreach(names,
    function(_, value)
      environment[string.lower(value)] = true
    end ) -- foreach
  end -- for

  -- ambiance callback
  callback_playambiance(wc[#wc])
end -- set_environment

function playstep()

  if (not foundstep) or (not environment) or (not room) then
    return 0
  end -- if

  foundstep = false

  -- Stop here if aquatic
  if environment.marine
  or string.find (room, "aquatic") then
    mplay ("steps/swim")
    return 1
  end -- if

  local file
  local function set_type(t, type, check)
    local ok
    for _, keyword in ipairs(t) do
      if string.find(string.lower(check), keyword) then
        file = type
        ok = 1
        break
      end -- if
    end -- for

    return ok
  end -- check_type

  local deserts = {"desert", "beach", "shore", "sand", "wasteland"}
  local forests = {"forest", "woods", "field", "grass", "jungle", "glade", "dale", "farm", "glen"}
  local muddy = {"mud", "swamp", "marsh"}
  local flying = {"fly", "float", "hover"}
  local ducts = {"duct", "crawlspace"}
  local skating = {"skate", "rollerblade"}


  if set_type(deserts, "desert", room) == 1
  or set_type(forests, "forest", room) == 1
  or set_type(muddy, "mud", room) == 1
  or set_type(ducts, "duct", room) == 1
  or set_type(flying, "fly", footstep) == 1
  or set_type(skating, "skate", footstep) == 1 then
    mplay("steps/"..file)
    return 1
  end -- if

  -- play sounds if environment is starship.
  if environment.name == "starship" then
    mplay ("steps/starship")
    return 1
  end -- if

  -- play sound if environment is station 
  if environment.name == "station" then
    mplay ("steps/station")
    return 1
  end -- if

  if environment.indoors then
    mplay("steps/planet/indoors")
  else
    mplay("steps/planet/outdoors")
  end -- if

  return 1
end -- playstep

function playsocial(name, line, wc)
  -- Try to match social to file
  -- Game shortens the social text depending on what user typed.
  local socialtable = utils.readdir(config:get("SOUND_DIRECTORY")..SOUNDPATH.."social/"..wc[2].."/"..wc[1].."*"..EXTENSION) 
  -- check that table exists
  if type(socialtable) ~= 'table' then
    --Use a recursive check to find file in nuter directory.
    if wc[2] ~= "neuter" then
      wc[2] = "neuter"

      return playsocial(name, line, wc, "socials")
    else
      return 0
    end -- recursive
  end -- if social exists

  local social = string.match (
  string.gsub (next(socialtable), "%d+", ""), "("..string.lower(wc[1]).."[%w%W]+)")
  social = string.gsub (social, EXTENSION, "")

  mplay ("social/"..wc[2].."/"..social, "socials")
end -- playsocial

function callback_playambiance(roomtype)

  if (not environment)
  or not focusWindow
  or (cameraFeed)
  or config:get_option("background_ambiance").value == "no" then
    return 0
  end -- if

  local file = nil
  local fade = 0.8
  local names = utils.split(roomtype, " ")
  local rname = string.lower(names[#names])  

  if (environment.name == "starship") then

    local r = rooms.starship[rname]
    if environment.unpowered then
      file = "starship_unpowered"
    elseif r then
      file = r
    end -- if

  elseif (environment.name == "room") then
    if (environment.outdoors) then
      -- probably a roid.
      file = "asteroid"
    end -- if

  elseif (environment.name == "planet") then
    if environment.marine then
      file = "marine"
    elseif environment.rocky and environment.outdoors then
      file = "rocky"
    elseif environment.river then
      file = environment.outdoors and "lake" or "indoorRiver"
    elseif (environment.digsite) and (environment.indoors) and (environment.safe) then
      file = "cave"
    elseif environment.terrestrial and environment.outdoors then
      file = "terrestrial"
    elseif environment.transterrestrial and environment.outdoors then
      file = "transterrestrial"
    elseif environment.ice and environment.outdoors then
      file = "ice"

    end -- if

  elseif (environment.name == "vehicle") then
    if environment.unpowered then
      file = "starship_unpowered"
    else
      file = "vehicle"
    end -- if
  end -- if

  if (not file)
  and (rooms[environment.name]) then
    file = rooms[environment.name][rname]
  end -- if

  if file ~= nil then
    if file ~= ambianceFile then
      ambianceFile = file -- avoid repeat loops.
      mplay("ambiance/"..file, "ambiance", 1, nil, 1, 1, fade) 
    end -- if
  else
    stop("ambiance", nil, 1, fade) -- fade out previous
    ambianceFile = nil
  end -- if



end -- playambiance

function gagline(name, line, wc)
  if config:get_option("spam").value == "no" then
    print(line)
  else
  return 1
  end -- if

end -- gagline

function notepad_changelog(name, line, wc)

  local f = io.open(scripts.."changelog.txt", "r")
  if (f) then
    local text = f:read("*all")
    f:close()
    AppendToNotepad("Changelog", string.gsub(text, "\n", "\r\n"), "\r\n")
    ActivateNotepad("changelog")
  end -- if
end -- notepad_changelog

function replicate_line(line)
  Simulate("\r\n"..line.."\r\n")
end -- replicate_line

function print_hyperlink(l, text, hint, browser)
  browser = browser or 1
  local foreground = RGBColourToName(config:get_option("hyperlink_foreground_color").value)
  local background = RGBColourToName(config:get_option("hyperlink_background_color").value)

  Hyperlink(l, text, hint, foreground, background, browser)
  Note()

end -- print_hyperlink

function print_color(...)
  -- print lines with predefined colors:
  local content = {}

  for k,v in pairs({...}) do

    local group = v[2] or "default"
    content[#(content)+1] = RGBColourToName(
  config:get_option(group.."_color").value or 0)

    content[#(content)+1] = RGBColourToName(
    config:get_option("background_color").value)
    content[#(content)+1] = v[1]
  end -- for
  ColourNote(unpack(content))
end -- print_color



]]>
</script> 


</muclient>
