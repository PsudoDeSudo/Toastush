<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, January 30, 2022, 4:53 AM -->
<!-- MuClient version 5.05 -->

<!-- Plugin "updater" generated by Plugin Wizard -->

<!--
-->

<muclient>
<plugin
   name="updater"
   author="Erick Rosso"
   id="508bd88f4d441f81466bf471"
   language="Lua"
   purpose="In line updater for Toastush."
   date_written="2022-01-30 04:49:37"
   requires="5.05"
   version="2.6"
   >
   <description trim="y">

    Syntax: update [options]
      -c | --clean-run: Download and remove unindexed files.
      -d | --dry-run: Perform checksum and indicate updates.
      -e | --error-suppress: Download and suppress error messages.
      -f | --confirm: Confirm large downloads.
      -h | --help: View help.
      -q | --quiet: Download and suppress noisy output.
      -s | --safe-run: Download and keep a backup of updated files.
      -v | --verbose: Download and print verbose output.
      -V | --version: Plugin version.


    The updater compares a local index with a given remote index. After determining its equality to be false, the updater downloads the remote index and applies the changes.
    During Clean-Mode, the updater will remove unindexed files, note that this process could be potentially destructive.
    The updater will override  any updated files while in its default mode. To prevent this, run the updater in Safe-Mode.
    To view a list of pending changes without applying any, run the updater in Dry-Run-Mode
    To view this help, type update [-h|--help]

    E.G update >> Apply updates with default settings.
    E.G update -q -s >> Download updates quietly and keep local backups.
    E.G update -v -c >> Download updates, printing verbose messages and removing untracked files.
    E.G update -e -f >> Confirm large update and suppress any error messages.


   </description>
</plugin>
<!--  Get our standard constants -->

<include name="constants.lua"/>
<aliases>

  <alias
  enabled="y"
   script="OnHelp"
   match="^update +(?:-h|--help)$"
   regexp="y"
   send_to="12"
  >
  </alias>

  <alias
  enabled="y"
   match="^update +(?:-V|--version)$"
   regexp="y"
   send_to="12"
  >
  <send>print("-- Updater Version: ", GetPluginInfo(GetPluginID(), 19), "--")</send>
  </alias>

  <alias
  enabled="y"
   name="updater"
   script="detect_updates"
   match="^update( .+?)?$"
   regexp="y"
   send_to="12"
  >
  </alias>

  <alias
   enabled="y"
   match="^index (.+?)$"
   ignore_case="y"
   regexp="y"
   send_to="12"
  >
  <send>
   print("Generating index. Please wait.")
   local e = generate_index("%1")

   if (e == 1) then
     print("Index file successfully created.")
   else
     print("Unable to generate the index file.")
   end -- if
  </send>
  </alias>

</aliases>

<script>

<![CDATA[

-------------------------
-- static -- 
-- Update the following variables

delay = 0.5
timeout = 30
download_size_limit = 20

update_url = "https://raw.githubusercontent.com/PsudoDeSudo/Toastush/main"
index_file = "index-v5.manifest"
check_update_url = string.format("%s/%s", update_url, index_file)
indexf = utils.split(index_file, ".")
plugins = GetInfo(60)
homedir = GetInfo(64)
sounds = GetInfo(74)


-- include all directories for the indexer to check here.
-- include in the following format,
-- directory, file-extension


update_dir = {
  [homedir..indexf[1]] = "."..indexf[2],
  [plugins.."updater"] = ".xml",
  [plugins.."toastush"] = ".xml",
  [sounds.."miriani/"] = ".ogg",
  [homedir.."lua/miriani/scripts/"] = ".lua",
  [homedir.."lua/miriani/"] = ".txt",


}



-----------------
-- Do not edit these variables unless you have reason for it.

tfile = nil
download_status = nil


option_flags = {
  ["^--verbose$"] = "verbose",   ["^-v$"] = "verbose",
  ["^--dry-run$"] = "dry",   ["^-d$"] = "dry",
  ["^--errors-suppress$"] = "errors",   ["^-e$"] = "errors",
  ["^--clean-run$"] = "clean",   ["^-c$"] = "clean",
  ["^--confirm$"] = "confirm",   ["^-f$"] = "confirm",
  ["^--quiet$"] = "quiet",   ["^-q$"] = "quiet",
  ["^--safe-run$"] = "safe",   ["^-s$"] = "safe",

  }-- option_flags


-------------------------
--callbacks --

function OnPluginInstall()
  wait = assert(require("wait"))
  async_ok, async = pcall(require, "async")
end -- OnPluginInstall



function OnHelp(name, line, wc)
  print(GetPluginInfo(GetPluginID(), 3))

end -- OnHelp


-------------------------
-- routines --


function detect_updates(name, line, wc)

  local options = parse_options(wc[1])

  print("- Checking for updates...")

  EnableAlias("updater", 0)
  wait.make(
  function()
    local start_time = os.time()
    local ret, file = checksum(check_update_url, options)

    if ret then
      print("- Nothing to do. All up-to-date!")
    elseif file ~= -1 then
      -- Work to do.

      local index_file_content = read_file(index_file)

      local json = require("json.decode")

      local remote_ok, remote_index = pcall(json.decode, file)
      local local_ok, local_index = pcall(json.decode, index_file_content)

      -- Did we get valid json.
      if (not local_ok) or (not remote_ok) then
        remote_index, local_index = {}, {}
        if (not local_ok)
        and (not options.errors) then
          print("> Error: Malformed JSON in local index.")
        end -- if

        if (not remote_ok)
        and (not options.errors) then
          print("> Error: Malformed JSON in remote index.")
        end -- if
      end -- if

      local create, delete, update = build_updates(local_index, remote_index, options)

      if not options.quiet then
        print(
        "- ", table.getn(create), " to create.",
        "- ", table.getn(delete), " to delete.",
        "- ", table.getn(update), " to update.")
      end -- if

      if next(create) or next(delete) or next(update) then
        if options.verbose then
          print(
          "> Create := ", table.concat(keys(create), ", "), "\n",
          " > Delete := ", table.concat(keys(delete), ", "), "\n",
          " > Update := ", table.concat(keys(update), ", "))
        end -- if

        local sizeof = (table.getn(keys(create)) + table.getn(keys(update)))

        if options.dry then
          print("- Dry-run: Exiting...")

        elseif (sizeof >= download_size_limit)
        and (not options.confirm) then
          print("- ", sizeof, " files to download. Run `update -f' to confirm. Aborting...")

        else -- Execute

           local create_count, update_count = download_updates(create, update, options)
          local delete_count = delete_unindexed_files(delete, options)

          print(
          "- ", create_count, " files created.",
          " ", delete_count, " files deleted.",
          " ", update_count, " files updated.")
          broadcast_event(create, delete, update)
          reload_plugins()
        end -- if
      else -- pending delete
        print("- Untracked files. Run `update -c [options]' to clean directory.")

      end -- if

    end -- if

    local elapse = os.time() - start_time
    print("Done! Elapsed time:", elapse, elapse == 1 and "second." or "seconds.")
    EnableAlias("updater", 1)

  end -- function
  ) -- coroutine

end -- detect_updates

-- @coroutine
function checksum(url, options)
  local path = require("pl.path")

  if (not path.isfile(GetInfo(64)..index_file)) then
    local e = generate_index(index_file)
    if (not options.errors) and e == 0 then
      print("Error: Unable to generate the index file.")
    end -- if


  end -- if
  local local_hash = get_hash_file(index_file)

  if options.verbose then
    print("> Local hash := ", local_hash)
  end -- if

  download(url, options)

  if (download_status == 200) then
    -- downloaded successfully.
    local remote_hash = get_hash(file)
    if options.verbose then
      print("> Remote hash := ", remote_hash)
    end -- if

    return remote_hash ==     local_hash, file
  else -- something went wrong
    return false, ret
  end -- if

end -- checksum

-- @coroutine
function download(url, options)
  download_status = nil

  if (async_ok) then
    async.doAsyncRemoteRequest(url, callback_download, "HTTPS", timeout)

    if options.verbose then
      print("- Hit: ", url .. "...")
    end -- if

    SetStatus("Downloading: "..url.."...")

    repeat
      wait.time(delay)
    until download_status ~= nil

    if (download_status ~= 200) then
      if (not options.errors) then
        print("- Error accessing ", url, "- Status: ", download_status)
      end -- if
    end -- if


  else
    if (not options.errors) then
      print("> Error: Couldn't load the network components.")
    end -- if
  end -- if

  SetStatus("Ready")
end -- download

function callback_download(res, page, status, headers, full_status, url)
  download_status = status

  if (status == 200) then
    file = page
  end -- if
end -- callback_download

function build_updates(current, pending, options)
  local path = require("pl.path")

  -- iterate through the index.
  -- If file exists in current but not pending,
  -- Flag for deletion.
  -- If file exists in pending but not current,
  -- Flag for creation.
  -- If file exists in both index, but have different hashes,
  -- Flag for update.

  local create, delete, update = {}, {}, {}

  for key, file in pairs(pending) do

    if (not current[key]) or (not path.isfile(key)) then
      create[#create + 1] = {key, file}
    elseif file.hash ~= current[key].hash then
      update[#update + 1] = {key, file}
    else
      -- -- Nothing to be done
    end -- if
  end -- for

  if options.clean then
    -- Find deleted files.
    for key, file in pairs(current) do

      if (not pending[key]) then
        delete[#delete + 1] = {key, file}
      end -- if
    end -- for
  end -- if


  return create, delete, update
end -- build_updates

-- @coroutine
function download_updates(create, update, options)

  local create_count = 0
  for _, index in ipairs(create) do
    local lpath, data = index[1], index[2]
    download(data.url, options)

    if (download_status == 200)
    and file then

      if (makefile(lpath, file, options) == 1) then
        create_count = create_count + 1

        if (not options.quiet) then
          progress_report(table.getn(keys(create)), create_count, "Creating Files")
        end -- if
      end -- if
    end -- if
  end -- for    

  local update_count = 0
  for i, index in ipairs(update) do
    local lpath, data = index[1], index[2]
    download(data.url, options)

    if (download_status == 200)
    and file then

      if options.safe then
        os.rename(lpath, lpath..".old")
      end -- if

      if (makefile(lpath, file, options) == 1) then
        update_count = update_count + 1

        if (not options.quiet) then
          progress_report(table.getn(keys(update)), update_count, "Updating Files")
        end -- if
      end -- if
    end -- if
  end -- for

  return create_count, update_count
end -- download_updates

function delete_unindexed_files(delete, options)
  local path = require("pl.path")

  local delete_count = 0
  for _, index in ipairs(delete) do
    local lpath = index[1]

    if path.isfile(lpath) then

      if options.safe then
        print("> Safe-mode overrides clean-mode. Exiting...")
        break
      else -- safe to delete

        local filename, dir = path.splitpath(lpath)
        os.remove(lpath)
        utils.shellexecute("cmd", "/C rmdir "..filename, dir, nil, 0)
        delete_count = delete_count + 1

        if (not options.quiet) then
          progress_report(table.getn(keys(delete)), delete_count, "Deleting Files")
        end -- if

      end -- if
    end -- if
  end -- for    

  return delete_count
end -- delete_unindexed_files

function broadcast_event(create, delete, update)
  local json = require("json.encode")
  local event = {
  ["create"] = create,
  ["delete"] = delete,
  ["update"] = update
  } -- event

  local ok = BroadcastPlugin(1, json.encode(event))

  return ok
end -- broadcast_event


function reload_plugins()

  local pid = GetPluginID()
  local plugins = GetPluginList()

  for _, id in ipairs(plugins) do

    if (id ~= pid) then
      local res, ret = CallPlugin(id, "on_plugin_update")

      if (ret == 1) then
        local ok, msg = ReloadPlugin(id)

        if ok ~= 0 then
          -- Could not reload:
          print(msg)
        end -- if
      end -- if
    end -- if
  end -- for

  return 1
end -- reload_plugins


-------------------------
-- utils --

function parse_options(arg)

  local opt = {}

  local input = utils.split(arg, " ")

  for _, value in ipairs(input) do

    table.foreach(option_flags,
    function(k, v)

      if string.match(value, k) then
        opt[v] = true
      end -- if
    end -- function
    ) -- foreach
  end -- for

  return opt
end -- parse_options

function get_hash(content)
  return utils.tohex(utils.md5(string.gsub(
content, "\r", "\n")))
end -- get_hash

function get_hash_file(filename)

  local file, content
  local path = require("pl.path")

  file = io.open(path.relpath(filename), "rb")

  if file then
    content = file:read("*all")
    file:close()
  end -- if

  local hash
  if (content) then
    hash = get_hash(content)
  end -- if

  return hash
end -- get_hash_file

function keys(t)
  local keys = {}
  for _, i in ipairs(t) do
    keys[#keys + 1] = i[1]
  end -- for
  return keys
end -- keys

-- @coroutine
function progress_report(pending, complete, text)

  local percent = (complete / pending) * 100
  if (percent == 100)
  or (not waiting_to_report) then
    Simulate(string.format("^%s: %.0f%%...", text, percent).."\n")

    waiting_to_report = true
    wait.time(3)
    waiting_to_report = nil
  end -- if

end -- progress_report

function makepath(lpath)
  local t, e, ok

  t, e = utils.readdir(lpath)

  if (not t) then
    local path = require("pl.path")

    local basepath = string.gsub(GetInfo(59), "\\", "/")
    local relpath = path.relpath(lpath, basepath)

    ok, e = utils.shellexecute("cmd", "/C mkdir " .. relpath, basepath, "open", 0)
  else
    ok = true
  end -- if

  return ok
end -- makepath

function makefile(lpath, data, options)
  local path = require("pl.path")
  local directory, filename = path.splitpath(lpath)
  local t = utils.readdir(directory.."/*")

  if (type(t) == 'table') then
    -- directory exists.

    os.rename(lpath, lpath..".temp")
  else
    local ok = makepath(directory)

    -- suspend for a beat for the directory.
    wait.time(0.01)

    if not ok then
      if (not options.errors) then
        print("> Unable to create the directory: ", lpath, ".")
      end -- if
      return 0
    end -- if
  end -- if

  local new_file, msg = io.open(lpath, "wb")
  if new_file then
    new_file:write(data)
    new_file:flush()
    new_file:close()
    if (type(t) == 'table') then
      os.remove(lpath..".temp")
    end -- if

  else -- failed to create.
    if (type(t) == 'table') then
            os.rename(lpath..".temp", lpath)
    end -- if

    if (not options.errors) then
      print("Unable to create the file: ", filename, "- ", msg)
    end -- if

    return 0
  end -- if

  return 1
end -- makefile

  function read_file(filename)
  local file = io.open(filename, "rb")
  local content
  if file then
    content = file:read("*all")
    file:close()
  end -- if

  return content
end -- read_file


function write_file(filename, manifest)

  local f = io.open(filename, "w")

  if (f) then
    f:write(manifest)
    f:close()
  return 1
  end -- if
end -- write_file

function generate_index(file)
  local path = require("pl.path")
  local json = require("json.encode")
  -- create an index for the updater.
  -- Users won't have to call this unless they are maintaining their own package.

  local ok
  local filename = file or index_file
   local manifest = {}

  local function recursive_index(dir, ph, ex)
    table.foreach(dir,
    function (k, v)
      if v.directory and (not string.find(k, "%.")) then

        -- Recursive index into filesystems.
        local sub_dir = utils.readdir(ph..k.."/*")
        recursive_index(sub_dir, ph..k.."/", ex)
      end -- if
      if path.extension(k) == ex then


        local dest = string.gsub(path.relpath(ph), "\\", "/")
        if (path.isfile(dest..ex)) then
          dest = dest..ex
else
          dest = dest.."/"..k
        end -- if

        manifest[dest] = {
        name = k,
        hash = get_hash_file(dest),
        url = string.format("%s/%s", update_url, dest)
        } -- manifest
 
      end -- if
    end ) -- foreach
  end -- recursive_index

  for ph, ext in pairs(update_dir) do
    dir = utils.readdir(ph.."*")

    if dir then
      recursive_index(dir, ph, ext)
    end -- if

  end -- for

  local serialized = json.encode(manifest)

  local e = write_file(filename, serialized)
  if (e) then
    ok = 1
  else
    ok = 0
  end -- if

  return ok
end -- generate_index

]]>
</script>
</muclient>
