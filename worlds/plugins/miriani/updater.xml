<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, January 30, 2022, 4:53 AM -->
<!-- MuClient version 5.05 -->

<!-- Plugin "updater" generated by Plugin Wizard -->

<!--
Portions of code sourced from plugins_updater for Materia Magica.
-->

<muclient>
<plugin
   name="updater"
   author="Erick Rosso"
   id="508bd88f4d441f81466bf471"
   language="Lua"
   purpose="In line updater for Toastush."
   date_written="2022-01-30 04:49:37"
   requires="5.05"
   version="1.0"
   >
   <description trim="y">

    Syntax: update [options]
      -c: Clean-Mode: Download and remove unindexed files.
      -d: Dry-Run-Mode: Perform checksum and indicate updates.
      -q: quiet-mode: Download and suppress noisy output.
      -s: Safe-Mode: Download and keep a backup of updated files.
      -v: Verbose-Mode: Download and print verbose output.

    The updater compares a local index with a given remote index. After determining its equality to be false, the updater downloads the remote index and applies the changes.
    During Clean-Mode, the updater will remove unindexed files, note that this process could be potentially destructive.
    The updater's will override  any updated files while in its default mode. To prevent this, run the updater in Safe-Mode.
    To view a list of pending changes without applying any, run the updater in Dry-Run-Mode.

   </description>
</plugin>
<!--  Get our standard constants -->

<include name="constants.lua"/>
<aliases>

  <alias
  enabled="y"
   script="OnHelp"
   match="^update +(?:-h|--help)$"
   regexp="y"
   send_to="12"
  >
  </alias>


  <alias
  enabled="y"
   name="updater"
   script="detect_updates"
   match="^update( .+?)?$"
   regexp="y"
   send_to="12"
  >
  </alias>

</aliases>

<script>

<![CDATA[

-------------------------
-- static -- 

thread = nil
update_url = "https://erosso.net/projects/files/toastush/index-v2.manifest"
index_file = "index-v2.manifest"
timeout = 120
delay = 0.5


-------------------------
--callbacks --

function OnPluginInstall()
  wait = assert(require("wait"))
  async_ok, async = pcall(require, "async")
end -- OnPluginInstall

function OnHelp(name, line, wc)
  print(GetPluginInfo(GetPluginID(), 3))

end -- OnHelp


-------------------------
-- routines --


function detect_updates(name, line, wc)

  local path = require("pl.path")

  if not path.isfile(index_file) then
    print("> Error: No index '"..index_file.."' - Cannot begin update.")
    return 0
  end -- if

  local options = parse_options(wc[1])

  print("- Checking for updates...")

  EnableAlias("updater", 0)
  wait.make(
  function()
    local ret, file = checksum(update_url, options)

    if ret then
      print("- Nothing to do. All up-to-date!")
    elseif file ~= -1 then
      -- Work to do.

      local index_file_content = read_file(index_file)

      local json = require("json.decode")

      local remote_ok, remote_index = pcall(json.decode, file)
      local local_ok, local_index = pcall(json.decode, index_file_content)

      -- Did we get valid json.
      if (not local_ok) or (not remote_ok) then
        remote_index, local_index = {}, {}
        if not local_ok then print("> Error: Malformed JSON in local index.") end
        if not remote_ok then print("> Error: Malformed JSON in remote index.") end
      end -- if

      local create, delete, update = build_updates(local_index, remote_index, options)

      if not options.quiet then
        print(
        "- ", table.getn(create), " to create.",
        " - ", table.getn(delete), " to delete.",
        " - ", table.getn(update), " to update.")
      end -- if

      if next(create) or next(delete) or next(update) then
        if options.verbose then
          print(
          "> Create := ", table.concat(keys(create), ", "), "\n",
          " > Delete := ", table.concat(keys(delete), ", "), "\n",
          " > Update := ", table.concat(keys(update), ", "))
        end -- if

        if options.dry then
          print("- Dry-run: Exiting...")
        else

          local create_count, update_count = download_updates(create, update, options)
          local delete_count = delete_unindexed_files(delete, options)

          print(
          "- ", create_count, " files created.",
          " ", delete_count, " files deleted.",
          " ", update_count, " files updated.")

          broadcast_event(create, delete, update)
          reload_plugins()
        end -- if
      end -- if


    end -- if

    print("Done!")
    EnableAlias("updater", 1)


  end -- function
  ) -- coroutine


end -- detect_updates

-- @coroutine
function checksum(url, options)
  local local_hash = get_hash_file(index_file)

  if options.verbose then
    print("> Local hash := ", local_hash)
  end -- if

  local ret, file = download(url, options)
  if file then
    -- downloaded successfully.
    local remote_hash = get_hash(file)
    if options.verbose then
      print("> Remote hash := ", remote_hash)
    end -- if

    return remote_hash ==     local_hash, file
  else -- something went wrong
    return false, ret
  end -- if

end -- checksum

-- @coroutine
function download(url, options)

  local res, file, status, headers, full_status, ret

  if (async_ok) and (not thread) then
    thread = async.request(url, "HTTPS")

    if not options.quiet then
      print("- Downloading: ", url .. "...")
    end -- if

    SetStatus("Downloading file: "..url.."...")
    if async_ok then
      local waiting = 0
      repeat
        wait.time(delay)
        waiting = waiting + 1
      until (not thread:alive())
      or waiting >= timeout

      res, file, status, headers, full_status = thread:join()

      thread = nil

      if status == 200 then
        ret = 1
      else -- http access error

        if not options.quiet then
          print("- Error accessing ", url, " - Status: ", status)
        end -- if
      ret = status
      end -- if
    end -- if

    SetStatus("Ready")
  else
    print("** updater Error: couldn't load the network components. **")
    ret = -1
  end -- if
  return ret, file

end -- download

function build_updates(current, pending, options)
  local path = require("pl.path")

  -- iterate through the index.
  -- If file exists in current but not pending,
  -- Flag for deletion.
  -- If file exists in pending but not current,
  -- Flag for creation.
  -- If file exists in both index, but have different hashes,
  -- Flag for update.

  local create, delete, update = {}, {}, {}

  for key, file in pairs(pending) do

    if (not current[key]) or (not path.isfile(key)) then
      create[#create + 1] = {key, file}
    elseif file.hash ~= current[key].hash then
      update[#update + 1] = {key, file}
    else
      -- -- Nothing to be done
    end -- if
  end -- for

  if options.clean then
    -- Find deleted files.
    for key, file in pairs(current) do

      if (not pending[key]) then
        delete[#delete + 1] = {key, file}
      end -- if
    end -- for
  end -- if


  return create, delete, update
end -- build_updates

-- @coroutine
function download_updates(create, update, options)

  local create_count = 0
  for _, index in ipairs(create) do
    local lpath, data = index[1], index[2]
    local ret, file = download(data.url, options)

    if ret == 1 and file then

      if makefile(lpath, file, options) == 0 then
        break
      else -- file created.
        create_count = create_count + 1
      end -- if
    end -- if
  end -- for    

  local update_count = 0
  for i, index in ipairs(update) do
    local lpath, data = index[1], index[2]
    local ret, file = download(data.url, options)

    if ret == 1 and file then

      if options.safe then
        os.rename(lpath, lpath..".old")
      end -- if

      if makefile(lpath, file, options) == 0 then
        break
      else -- file updated.
        update_count = update_count + 1
      end -- if
    end -- if
  end -- for

  return create_count, update_count
end -- download_updates

function delete_unindexed_files(delete, options)
  local path = require("pl.path")

  local delete_count = 0
  for _, index in ipairs(delete) do
    local lpath = index[1]

    if path.isfile(lpath) then

      if options.safe then
        print("> Safe-mode overrides clean-mode. Exiting...")
        break
      else -- safe to delete
        os.remove(lpath)
        delete_count = delete_count + 1
      end -- if
    end -- if
  end -- for    

  return delete_count
end -- delete_unindexed_files

function broadcast_event(create, delete, update)
  local json = require("json.encode")
  local event = {
  ["create"] = create,
  ["delete"] = delete,
  ["update"] = update
  } -- event

  local ok = BroadcastPlugin(1, json.encode(event))

  return ok
end -- broadcast_event

function reload_plugins()

  local pid = GetPluginID()
  local plugins = GetPluginList()

  for _, id in ipairs(plugins) do

    if (id ~= pid) then
      local res, ret = CallPlugin(id, "on_plugin_update")

      if (ret == 1) then
        local ok, msg = ReloadPlugin(id)

        if ok ~= 0 then
          -- Could not reload:
          print(msg)
        end -- if
      end -- if
    end -- if
  end -- for

  return 1
end -- reload_plugins


-------------------------
-- utils --

function parse_options(arg)

  local opt = {}
  local flags = {
  verbose = "^-v$",
  dry = "^-d$",
  clean = "^-c$",
  quiet = "^-q$",  quiet = "^-q$",
  safe = "^-s$",
  }-- flags

  local input = utils.split(arg, " ")

  for _, value in ipairs(input) do

    table.foreach(flags,
    function(k, v)


      if string.match(value, v) then
        opt[k] = true
      end -- if
    end -- function
    ) -- foreach
  end -- for

  return opt
end -- parse_options

function get_hash(content)
  return utils.tohex(utils.md5(string.gsub(
content, "\r", "\n")))
end -- get_hash

function get_hash_file(filename)

  local file, content
  local path = require("pl.path")

  file = io.open(path.relpath(filename), "rb")

  if file then
    content = file:read("*all")
    file:close()
  end -- if

  local hash
  if (content) then
    hash = get_hash(content)
  end -- if

  return hash
end -- get_hash_file

function keys(t)
  local keys = {}
  for _, i in ipairs(t) do
    keys[#keys + 1] = i[1]
  end -- for
  return keys
end -- keys

function makepath(path)
  local t, e, ok

  t, e = utils.readdir(path)

  if (not t) then
    t = utils.split(path, "/")
    local dirname = t[#t]

    path = string.gsub(path, dirname, "")

    ok, e = utils.shellexecute("cmd", "/C mkdir " .. dirname, path, "open", 0)

  else
    ok = true
  end -- if

  return ok
end -- makepath

function makefile(lpath, file, options)
  local ok = makepath(lpath)
  if not ok then
    if options.verbose then
      print("> Unable to create the directory.")
    end -- if

    if options.safe then
      print("> Failed to create directory. - Safe mode: Exiting...")
      return 0
    end -- if


  else -- ok
    local new_file = io.open(lpath, "wb")

    new_file:write(file)
    new_file:flush()
    new_file:close()
  end -- if

  return 1
end -- makefile

  function read_file(filename)
  local file = io.open(filename, "rb")
  local content
  if file then
    content = file:read("*all")
    file:close()
  end -- if

  return content
end -- read_file

]]>
</script>
</muclient>
